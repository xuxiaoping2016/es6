<!DOCTYPE html>
<html lang="en">

<head>
    <base href="/" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="format-detection" content="telephone=no" />
    <title>字符串的 Iterator 接口</title>
</head>

<body>
    <script type="text/javascript">
        //================================================================
        // function* helloWorldGenerator() {
        //     yield 'hello';
        //     yield 'world';
        //     return 'ending';
        // }

        // var hw = helloWorldGenerator();
        // console.log(hw.next())
        // console.log(hw.next())
        // console.log(hw.next())

        //================================================================
        // function* gen() {
        //     // some code
        // }

        // var g = gen();

        // console.log(g);
        // console.log(g[Symbol.iterator]() === g)

        //================================================================
        
        // function* f() {
        //     for (let i = 0; true; i++) {
        //         console.log("reset before",reset)
        //         var reset = yield i;
        //         console.log("reset",reset)
        //         if (reset ==2) {
        //             i = 7;
        //         }

        //         if (reset == 8) {
        //             i = 10;
        //         }
        //     }
        // }

        // var g = f();

        // console.log(g.next()) // { value: 0, done: false }
        // console.log('---------------------------')
        // console.log(g.next()) // { value: 1, done: false }
        // console.log('---------------------------')
        // console.log(g.next(2))
        // console.log('---------------------------')
        // console.log(g.next(8))

        //================================================================
        // function* foo(x) {
        //     var y = 2 * (yield(x + 1));
        //     var z = yield(y / 3);
        //     return (x + y + z);
        // }

        // var a = foo(5);
        // a.next() // Object{value:6, done:false}
        // a.next() // Object{value:NaN, done:false}
        // a.next() // Object{value:NaN, done:true}

        // var b = foo(5);
        // b.next() // { value:6, done:false }
        // b.next(12) // { value:8, done:false }
        // b.next(13) // { value:42, done:true }

        //================================================================
        // function* dataConsumer() {
        //     console.log('Started');
        //     console.log(`1. ${yield}`);
        //     console.log(`2. ${yield}`);
        //     return 'result';
        // }

        // let genObj = dataConsumer();
        // console.log(genObj.next());
        // // Started
        // //{value: undefined, done: false}
        // console.log('---------------------------')

        // console.log(genObj.next('a'));
        // // 1. a
        // //{value: undefined, done: false}
        // console.log('---------------------------')

        // console.log(genObj.next('b'));
        // // 2. b
        // // value: "result", done: true}
        // console.log('---------------------------')

        //================================================================
        function wrapper(generatorFunction) {
            return function (...args) {
                let generatorObject = generatorFunction(...args);
                console.log(generatorObject.next());
                return generatorObject;
            };
        }

        // const wrapped = wrapper(function* () {
        //     console.log(`First input: ${yield}`);
        //     return 'DONE';
        // });

        // console.log(wrapped().next('hello!'))
        // First input: hello!
        //================================================================

        function* fibonacci() {
            let [prev, curr] = [0, 1];
            for (;;) {
                yield curr;
                [prev, curr] = [curr, prev + curr];
            }
        }

        // for (let n of fibonacci()) {
        // if (n > 1000) break;
        // console.log(n);
        // }

        //================================================================

        function* foo() {
            yield 2;
            yield 3;
            return "foo";
        }

        function* bar() {
            yield 1;
            var v = yield* foo();
            console.log("v: " + v);
            yield 4;
        }

        var it = bar();

        it.next()
        // {value: 1, done: false}
        it.next()
        // {value: 2, done: false}
        it.next()
        // {value: 3, done: false}
        it.next();
        // "v: foo"
        // {value: 4, done: false}
        it.next()
        // {value: undefined, done: true}

        //================================================================

        function* genFuncWithReturn() {
            yield 'a';
            yield 'b';
            return 'The result';
        }
        function* logReturned(genObj) {
            let result = yield* genObj;
            console.log(result);
        }

        // console.log([...logReturned(genFuncWithReturn())])

        //================================================================

        // 下面是二叉树的构造函数，
        // 三个参数分别是左树、当前节点和右树
        function Tree(left, label, right) {
            this.left = left;
            this.label = label;
            this.right = right;
        }

        // 下面是中序（inorder）遍历函数。
        // 由于返回的是一个遍历器，所以要用generator函数。
        // 函数体内采用递归算法，所以左树和右树要用yield*遍历
        function* inorder(t) {
            if (t) {
                yield* inorder(t.left);
                yield t.label;
                yield* inorder(t.right);
            }
        }

        // 下面生成二叉树
        function make(array) {
            // 判断是否为叶节点
            if (array.length == 1) return new Tree(null, array[0], null);
            return new Tree(make(array[0]), array[1], make(array[2]));
        }
        let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);

        // 遍历二叉树
        var result = [];
        for (let node of inorder(tree)) {
            result.push(node);
        }

        // console.log(result);
        // ['a', 'b', 'c', 'd', 'e', 'f', 'g']

        //================================================================
        var clock = function* () {
            while (true) {
                console.log('Tick!');
                yield;
                console.log('Tock!');
                yield;
            }
        };

        var c = clock();
        // c.next();  // Tick!
        // c.next();  // Tock!
        // c.next();  // Tick!
        // c.next();  // Tock!

        //================================================================
         let draw = function (count) {
                //具体抽奖逻辑
                console.info(`剩余${count}次`);
        };

        let residue = function* (count) {

                while (count>0){

                        count--;

                        yield draw(count);

                 }

        };

        let star = residue(5);

        let btn = document.createElement('button');

        btn.id='start';

        btn.textContent = '抽奖';

        btn.addEventListener('click',function () {

                star.next();

        })

        document.body.appendChild(btn);

        //================================================================


        //================================================================


        
        //================================================================
    </script>
</body>

</html>