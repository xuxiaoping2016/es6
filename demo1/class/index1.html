<!DOCTYPE html>
<html lang="en">

<head>
    <base href="/" />
    <meta charset="utf-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> -->
    <meta name="viewport" content="width=device-width, initial-scale=1,minmum-scale=1,maxmum-scale=1,user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="format-detection" content="telephone=no" />
    <title>class的基本语法</title>
</head>

<body>
    <script type="text/javascript">
        // 1、ES6 的class可以看作只是一个语法糖，它的绝大部分功能，
        // ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已
        //     2、定义“类”的方法的时候，前面不需要加上function这个关键字，
        //     直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。
        //     3、的内部所有定义的方法，都是不可枚举的（non-enumerable）
        //     4、类的属性名，可以采用表达式

        // 3-1、类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。

        // 5-1Class 表达式

        const MyClass = class Me {
            getClassName() {
                return Me.name;
            }
        };

        let inst = new MyClass();
        // console.log(inst.getClassName())
        // console.log(Me.name)

        // 5-2采用 Class 表达式，可以写出立即执行的 Class。

        let person = new class {
            constructor(name) {
                this.name = name;
            }

            sayName() {
                // console.log(this.name);
            }
        }('张三');

        person.sayName();
        // --------------------------------------------------------------
        // 6、不存在变量提升

        // 7、私有方法和私有属性 



        // 8、this指向
        class Logger {
            constructor() {
                // this.printName = this.printName.bind(this);
                this.printName = (name = 'there') => {
                    this.print(`Hello ${name}`);
                }
            }
            // printName(name = 'there') {
            //     this.print(`Hello ${name}`);
            // }



            print(text) {
                console.log(text);
            }
        }

        const logger = new Logger();
        //结构赋值不仅可以结构对象自身属性还可以结构对象原型上的属性
        const {
            printName
        } = logger;
        // printName();  // Uncaught TypeError: Cannot read property 'print' of undefined



        //使用Proxy
        function selfish(target) {
            const cache = new WeakMap();
            const handler = {
                get(target, key) {
                    const value = Reflect.get(target, key);
                    if (typeof value !== 'function') {
                        return value;
                    }
                    if (!cache.has(value)) {
                        cache.set(value, value.bind(target));
                    }
                    return cache.get(value);
                }
            };
            const proxy = new Proxy(target, handler);
            return proxy;
        }

        const logger2 = selfish(new Logger());

        // ----------------------------------
        // 9、name属性总是返回紧跟在class关键字后面的类名


        // 10、Class 的取值函数（getter）和存值函数（setter）

        class CustomHTMLElement {
            constructor(element) {
                this.element = element;
            }

            get html() {
                return this.element.innerHTML;
            }

            set html(value) {
                this.element.innerHTML = value;
            }
        }

        var descriptor = Object.getOwnPropertyDescriptor(
            CustomHTMLElement.prototype, "html"
        );

        // console.log(descriptor)

        // console.log("get" in descriptor) // true
        // console.log("set" in descriptor) // true


        // class Foo {
        //     static bar() {
        //         console.log("static", this)
        //         this.baz();
        //     }
        //     static baz() {
        //         console.log('hello');
        //     }
        //     baz() {
        //         console.log("obj", this)
        //         console.log('world');
        //     }
        // }

        // Foo.bar();

        // var obj = new Foo();
        // obj.baz();


        // ==================
        class Foo {
            // 写法一
            prop = 2

            // 写法二
            // static prop: 2
        }

        console.log(Foo.prop)
        // const obj2 = new Foo();
        // console.log(obj2, obj2.prop)
    </script>
</body>

</html>